// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@paymasters-io/library/OracleHelper.sol";
import "@paymasters-io/core/Core.sol";

contract TestCore is Test, Core {
    using OracleHelper for OracleQueryInput;

    IERC20 public testToken;
    address public testProxyOrFeed;
    string public testTicker;

    function setUp() public {
        vaa = msg.sender;
        testToken = new ERC20("Test Token", "TEST");
        testProxyOrFeed = address(0x1);
        testTicker = "TEST";
    }

    function testSetNodeSigners() public {
        address primarySigner = address(0x1);
        address secondarySigner = address(0x2);
        uint256 sigCount = 2;

        setNodeSigners(primarySigner, secondarySigner, sigCount);

        assertEq(signatureConf.verifyingSigner1, primarySigner, "Primary signer should match");
        assertEq(signatureConf.verifyingSigner2, secondarySigner, "Secondary signer should match");
        assertEq(uint256(signatureConf.validNumOfSignatures), sigCount, "Sig count should match");
    }

    function testAddSibling() public {
        address sibling = address(0x1);

        addSibling(sibling);

        assertTrue(isSibling[sibling], "Sibling should be added");
    }

    function testRemoveSibling() public {
        address sibling = address(0x1);

        addSibling(sibling);
        removeSibling(sibling);

        assertFalse(isSibling[sibling], "Sibling should be removed");
    }

    function testSetAccessControlSchema() public {
        AccessControlSchema memory schema = AccessControlSchema({
            accessControlType: AccessControlType.WHITELIST,
            accessList: [address(0x1)]
        });

        setAccessControlSchema(schema);

        assertEq(
            uint256(accessControlSchema.accessControlType),
            uint256(schema.accessControlType),
            "Access control type should match"
        );
        assertEq(accessControlSchema.accessList[0], schema.accessList[0], "Access list should match");
    }

    function testSetDefaultOracle() public {
        Oracle oracle = Oracle.CHAINLINK;

        setDefaultOracle(oracle);

        assertEq(uint256(defaultOracle), uint256(oracle), "Default oracle should match");
    }

    function testPreviewAccess() public {
        AccessControlSchema memory schema = AccessControlSchema({
            accessControlType: AccessControlType.WHITELIST,
            accessList: [address(0x1)]
        });

        setAccessControlSchema(schema);

        assertTrue(previewAccess(address(0x1)), "Address 0x1 should have access");
        assertFalse(previewAccess(address(0x2)), "Address 0x2 should not have access");
    }

    function testAddTokenTicker() public {
        addTokenTicker(testToken, testTicker);

        assertEq(tokenToInfo[testToken].ticker, testTicker, "Ticker should match");
    }

    function testAddTokenProxyOrFeed() public {
        addTokenProxyOrFeed(testToken, testProxyOrFeed);

        assertEq(tokenToInfo[testToken].proxyOrFeed, testProxyOrFeed, "Proxy/feed should match");
    }

    function testWithdraw() public {
        uint256 balanceBefore = address(this).balance;

        if (balanceBefore == 0) {
            payable(address(this)).transfer(1 ether);
            balanceBefore += 1 ether;
        }

        withdraw();

        uint256 balanceAfter = address(this).balance;

        assertEq(balanceAfter, 0, "Balance after withdraw should be zero");
    }

    function testPayDebt() public {
        address debtor = address(this);
        siblingsToDebt[debtor] += 1 ether;

        payDebt{value: 1 ether}(debtor);

        assertEq(siblingsToDebt[debtor], 0, "Debt after payDebt should be zero");
    }

    function testGetPriceFromOracle() public {
        addTokenProxyOrFeed(IERC20(address(0)), address(new MockAggregatorV3Interface(100)));
        addTokenProxyOrFeed(testToken, address(new MockAggregatorV3Interface(200)));

        uint256 expectedPrice = 50;
        uint256 price = _getPriceFromOracle(testToken, 100);

        assertEq(price, expectedPrice, "Price should match");
    }

    function testTransferTokens() public {
        uint256 amount = 1 ether;
        testToken.mint(address(this), amount);
        testToken.approve(address(this), amount);

        uint256 balanceBefore = testToken.balanceOf(vaa);

        _transferTokens(address(this), testToken, amount);

        uint256 balanceAfter = testToken.balanceOf(vaa);

        assertEq(balanceAfter - balanceBefore, amount, "Balance after transfer should increase by amount");
    }
}
